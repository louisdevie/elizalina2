import { BaseTarget } from '../decorators'
import * as ts from '@module/languages/ts/ast'
import { Parameter } from '@module/languages/ts/ast'
import { ElizalinaRuntimeConfig, PlaceholdersConfig } from '@module/codeGeneration/codeConfig'
import { randomHex } from '@module/helpers'
import { Message, MessageParameter, Translation, TypeHint, UserCode } from '@module/translations'
import { UserCodeInsertion } from '@module/codeGeneration/postProcessing'
import { AllTranslationReports } from '@module/checks/translations'

export default abstract class TSTarget extends BaseTarget {
  private readonly _interfaceName: string
  private readonly _functionName: string
  private readonly _userCodeInsertion: UserCodeInsertion
  private _reports?: AllTranslationReports

  public get userCodeInsertion(): UserCodeInsertion {
    return this._userCodeInsertion
  }

  public get interfaceName(): string {
    return this._interfaceName
  }

  public get functionName(): string {
    return this._functionName
  }

  protected constructor(interfaceName: string, functionName: string) {
    super()

    this._interfaceName = interfaceName
    this._functionName = functionName
    this._userCodeInsertion = new UserCodeInsertion()
  }

  private static generatePlaceholderKey(): string {
    return PlaceholdersConfig.userCodePlaceholderPrefix + randomHex()
  }

  protected async initThis(reports: AllTranslationReports): Promise<void> {
    this._reports = reports
  }

  /**
   * Creates a comment indicating that the file was generated.
   *
   * @param sources The path of the source file(s) from which it was generated.
   * @param tool The name and version of the tool that generated the file.
   * @protected
   */
  protected makeGeneratedNoticeComment(sources: string[], tool: string): ts.Comment {
    const formattedSources = sources.map((src) => `\n * ${src}`)
    return ts.blockComment(`Generated by ${tool} from the following files:${formattedSources}\n`)
  }

  /**
   * Creates an import statement for the global formatter.
   * @protected
   */
  protected makeFormatterImport(): ts.ProgramStatement {
    return ts.importDeclaration('value', ElizalinaRuntimeConfig.moduleName, [
      ts.importSpecifier('value', ElizalinaRuntimeConfig.globalFormatterInstanceName),
    ])
  }

  /**
   * Creates a placeholder expression to be replaced by user-defined code afterward.
   * @protected
   */
  protected makePlaceholderExpression(userCode: UserCode): ts.Identifier {
    const placeholder = TSTarget.generatePlaceholderKey()
    this._userCodeInsertion.addUserCode(placeholder, userCode)
    return ts.identifier(placeholder)
  }

  protected makeTranslationClass(
    translation: Translation,
    className: string,
  ): ts.ClassDeclarationWithName {
    const cls = ts.classDeclaration(className, {
      implements: [ts.tsClassImplements(this.interfaceName)],
    })

    for (const [key, message] of translation.messages) {
      cls.body.body.push(this.makeMessageMethod(key, message))
    })

    if (this._reports !== undefined) {
      for (const key of this._reports.missing.missingKeysIn(translation.id)) {
        cls.body.body.push(this.makeMissingMessageMethod(key))
      }
    }

    return cls
  }

  private makeMessageMethod(key: string, message: Message): ts.MethodDefinition {
    const params = message.parameters.map(this.makeMessageParameter.bind(this))
    return ts.methodDefinition(key, {
      accessibility: 'public',
      kind: params.length === 0 ? 'get' : 'method', // use getters when there are no parameters
      params,
      returnType: ts.tsTypeAnnotation(ts.tsStringKeyword()),
      body: ts.blockStatement(ts.returnStatement(this.makeMessageTemplate(message))),
    })
  }

  private makeMissingMessageMethod(key: string): ts.MethodDefinition {
    return ts.methodDefinition(key, {
      accessibility: 'public',
      kind: 'get',
      params: [],
      returnType: ts.tsTypeAnnotation(ts.tsStringKeyword()),
      body: ts.blockStatement(ts.returnStatement(ts.literal(`<${key}>`))),
    })
  }

  private makeMessageParameter(param: MessageParameter): Parameter {
    return ts.identifier(param.name, this.typeHintToTSType(param.typeHint))
  }

  private typeHintToTSType(typeHint: TypeHint): ts.TypeNode | undefined {
    let type = undefined

    switch (typeHint) {
      case TypeHint.None:
      case TypeHint.Mixed:
        type = ts.tsAnyKeyword()
        break

      case TypeHint.String:
        type = ts.tsStringKeyword()
        break

      case TypeHint.Number:
        type = ts.tsNumberKeyword()
        break

      case TypeHint.List:
        type = ts.tsArrayType(ts.tsAnyKeyword())
        break

      case TypeHint.Datetime:
        type = ts.tsTypeReference(ts.identifier('Date'))
        break
    }

    return type
  }

  private makeMessageTemplate(message: Message): ts.TemplateLiteral {
    const textElements = []
    const expressions = []

    let firstPart = true
    for (const part of message.content) {
      switch (part.type) {
        case 'text':
          textElements.push(part.value)
          break

        case 'formatting':
          if (firstPart) textElements.push('') // always start with a quasi

          if (part.format === undefined) {
            expressions.push(ts.identifier(part.parameterName))
          } else {
            expressions.push(
              ts.callExpression(
                this.makePlaceholderExpression(part.format),
                ts.identifier(part.parameterName),
              ),
            )
          }
      }
      firstPart = false
    }

    return ts.templateLiteral(textElements, expressions)
  }
}
